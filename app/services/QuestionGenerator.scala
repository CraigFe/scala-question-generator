package services

import models.Question
import scala.util.Random
import javax.inject._
import scala.annotation.tailrec

trait QuestionGenerator {
  def generateQuestion(lower: Int, upper: Int): Question
}

@Singleton
class AdditionQuestion extends QuestionGenerator {
  def n = 4                // The number of answers to include
  def lowerBound = 0       // The (inclusive) lower bound on the answer
  def upperBound = 1000000 // The (inclusive) upper bound on the answer

  /**
    * Implementation of the [[generateQuestion()]] method defined by the [[QuestionGenerator]] trait. This is the method
    * which is exposed to the REST API. Returns a random question with an answer in the range [lower, upper].
    *
    * @param lower   The (inclusive) lower bound of all answers to the question.
    * @param upper   The (includive) upper bound of all answers to the question.
    * @return        A randomly-generated question within an answer in the specified range.
    */
  override def generateQuestion(lower: Int, upper: Int): Question = {
    if (lower > upper) throw new IllegalArgumentException("Lower bound may not be greater than the upper bound.")

    // First generate the correct answer
    val ans = Random.nextInt(upper - lower + 1) + lower

    // Generate an addend and augend which sum to the correct value
    val addend = Random.nextInt(ans + 1)
    val augend = ans - addend

    // Generate the distractors and then return the question
    new Question(addend + " + " + augend + "?", generateAnswers(addend, augend))
  }

  /**
    * Takes as argument the addend and augend of the question, and returns a list of [[n]] integers, exactly one of
    * which is the correct answer.
    *
    * In general, it is a difficult problem to invent false answers (known as 'distractors') for use in multiple
    * choice questions. In this case, we simply mutate one of the digits in either the addend or the augend by adding
    * a randomly computed delta value. This will not always create 'convincing' potential answers, but it is better
    * than simply returning a range around the true answer.
    */
  private def generateAnswers(addend: Int, augend: Int): List[Int] = {
    Random.shuffle(
      variantQuestions(List((addend, augend))) // Generate alternative questions
        .map{case (a, b) => bounded(a + b)} // Calculate the answers to all questions, bounded in the correct range
    )
  }

  /**
    * A tail-recursive function to generate a list of [[n - 1]] alternative 'questions', represented as (addend, augend) pairs.
    * Each new question is generated by selecting one of the previously-generated questions at random and mutating one
    * of the digits in either the addend or the augend. If the new question has the same answer as one of the previous
    * questions, it is thrown out in order to avoid duplicates.
    */
  @tailrec
  private def variantQuestions(list: List[(Int, Int)], toGenerate: Int = n - 1): List[(Int, Int)] = {
    if (toGenerate == 0) list // We are done

    else {
      // Generate a new question by mutating one of the questions in the list
      val (addend, augend) = list(Random.nextInt(list.length))
      val newQuestion: (Int, Int) = if (Random.nextInt(2) == 0) (mutateDigit(addend), augend) else (addend, mutateDigit(augend))

      // Check for duplicate questions
      if (list.map{ case (a, b) => bounded(a + b) }.contains(bounded(newQuestion._1 + newQuestion._2)))
        variantQuestions(list, toGenerate) // Try again

      else
        variantQuestions(newQuestion :: list, toGenerate - 1) // Add answer to list and keep going
    }

  }

  /**
    * Utility function to bound an integer withint the lower and upper bounds for the question answer.
    */
  def bounded (x: Int) = math.min(math.max(x, lowerBound), upperBound)

  /**
    * Utility function to mutate a random digit in a given integer by adding a random delta value.
    */
  def mutateDigit(x: Int): Int = {

    // Compute a random delta
    val sign = if (Random.nextInt(2) == 0) -1 else 1
    val mantissa = Random.nextInt(4) + 1 // In range [1, 5]
    val exponent = Random.nextInt(base10Length(x))

    x + sign * mantissa * math.pow(10, exponent).toInt
  }

  /**
    * Utility function to return the number of digits in a positive integer when represented in base 10.
    */
  @tailrec
  private def base10Length(x: Int, i: Int = 1): Int =
    if (x < 10) i
    else base10Length(x / 10, i + 1)

}